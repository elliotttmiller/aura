""" Advanced Design Synthesis - Blender Mesh Engine ================================================== Revolutionary evolution beyond , implementing the dedicated Mesh Engine for the Unified Design Studio. This module serves as the "Blender Mesh Engine" - one half of the Advanced Design system: - High-level artistic mesh operations that complement NURBS precision - Advanced procedural displacement and sculpting capabilities - Seamless integration with the Master Control Room interface Key Innovations: - Pure mesh-based artistry operations (complementing NURBS precision) - High-level mesh functions mapped to AI construction_plan operations - Advanced surface treatments and organic modeling - Seamless integration with NURBS workflow Core Functions for AI Construction Plans: - apply_procedural_displacement(parameters) - Organic surface textures - perform_mesh_sculpting(parameters) - Artistic sculpting operations - run_advanced_retopology(parameters) - Mesh optimization - apply_generative_texture(parameters) - AI-generated surface patterns Implements Protocol 13: The Unified Studio Doctrine - Blender as Master Control Room + Mesh Engine Implements Protocol 14: AI as Advanced Design Architect - Intelligent MESH paradigm operations """ import os import sys import json import math import time import logging import numpy as np from argparse import ArgumentParser from typing import Dict, List, Tuple, Optional import bpy import bmesh import addon_utils from mathutils import Vector, Matrix # Import scientific libraries for basic geometry operations try: import numpy as np except ImportError as e: logging.warning(f"NumPy not available: {e}") # Basic fallback for coordinate operations # Setup professional logging logging.basicConfig(level=logging.DEBUG, format='[%(asctime)s] %(levelname)s %(message)s') logger = logging.getLogger(__name__) # ============================================================================= # BLENDER MESH ENGINE - HIGH-LEVEL ARTISTIC FUNCTIONS # ============================================================================= def apply_procedural_displacement(parameters: Dict) -> Dict[str, Any]: """ Mesh Engine: Apply procedural displacement for organic surface textures Creates organic, artistic surface details that complement NURBS precision. """ logger.info("ðŸŽ¨ Mesh Engine: Applying procedural displacement...") pattern_type = parameters.get('pattern_type', 'organic') displacement_strength = parameters.get('displacement_strength', 0.5) detail_scale = parameters.get('detail_scale', 1.0) try: # Get active object or create a base mesh if none exists obj = bpy.context.active_object if not obj or obj.type != 'MESH': # Create a base cylinder for displacement bpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=(0, 0, 0)) obj = bpy.context.active_object obj.name = "Displaced_Surface" # Enter edit mode to add displacement bpy.context.view_layer.objects.active = obj bpy.ops.object.mode_set(mode='EDIT') # Subdivide for detail bpy.ops.mesh.select_all(action='SELECT') bpy.ops.mesh.subdivide(number_cuts=3) # Return to object mode bpy.ops.object.mode_set(mode='OBJECT') # Add displacement modifier displacement_mod = obj.modifiers.new(name="_Displacement", type='DISPLACE') displacement_mod.strength = displacement_strength displacement_mod.mid_level = 0.5 # Create noise texture for displacement texture = bpy.data.textures.new(name="_DisplacementTexture", type='NOISE') texture.noise_scale = detail_scale displacement_mod.texture = texture logger.info(f"âœ… Procedural displacement applied: {pattern_type} pattern") return { 'status': 'SUCCESS', 'technique': 'apply_procedural_displacement', 'object': obj.name, 'pattern_applied': pattern_type, 'displacement_strength': displacement_strength } except Exception as e: logger.error(f"âŒ Procedural displacement failed: {str(e)}") return {'status': 'ERROR', 'error': str(e)} def perform_mesh_sculpting(parameters: Dict) -> Dict[str, Any]: """ Mesh Engine: Perform artistic mesh sculpting operations Applies artistic sculpting effects for organic, flowing designs. """ logger.info("ðŸŽ¨ Mesh Engine: Performing mesh sculpting...") sculpt_type = parameters.get('sculpt_type', 'artistic_flow') intensity = parameters.get('intensity', 0.5) preserve_geometry = parameters.get('preserve_geometry', True) try: obj = bpy.context.active_object if not obj or obj.type != 'MESH': # Create a base mesh for sculpting bpy.ops.mesh.primitive_uv_sphere_add(radius=1, location=(0, 0, 0)) obj = bpy.context.active_object obj.name = "Sculpted_Mesh" # Add subdivision surface for smooth sculpting if preserve_geometry: subsurf_mod = obj.modifiers.new(name="_Subsurf", type='SUBSURF') subsurf_mod.levels = 2 # Simulate sculpting by adding wave modifier for organic flow wave_mod = obj.modifiers.new(name="_Sculpt", type='WAVE') wave_mod.use_x = True wave_mod.use_y = True wave_mod.height = intensity * 0.3 wave_mod.width = 1.2 wave_mod.speed = 0.0 # Static wave for sculpted effect logger.info(f"âœ… Mesh sculpting applied: {sculpt_type} with intensity {intensity}") return { 'status': 'SUCCESS', 'technique': 'perform_mesh_sculpting', 'object': obj.name, 'sculpt_type': sculpt_type, 'intensity': intensity } except Exception as e: logger.error(f"âŒ Mesh sculpting failed: {str(e)}") return {'status': 'ERROR', 'error': str(e)} def run_advanced_retopology(parameters: Dict) -> Dict[str, Any]: """ Mesh Engine: Run advanced mesh retopology optimization Optimizes mesh topology for better performance and quality. """ logger.info("ðŸŽ¨ Mesh Engine: Running advanced retopology...") target_faces = parameters.get('target_faces', 1000) preserve_features = parameters.get('preserve_features', True) try: obj = bpy.context.active_object if not obj or obj.type != 'MESH': logger.warning("No mesh object for retopology") return {'status': 'NO_MESH', 'message': 'No mesh object available'} # Add remesh modifier for retopology remesh_mod = obj.modifiers.new(name="_Retopology", type='REMESH') remesh_mod.mode = 'VOXEL' remesh_mod.voxel_size = 0.1 remesh_mod.use_remove_disconnected = False if preserve_features: remesh_mod.adaptivity = 0.3 # Apply the modifier bpy.context.view_layer.objects.active = obj bpy.ops.object.modifier_apply(modifier=remesh_mod.name) logger.info(f"âœ… Advanced retopology completed for {obj.name}") return { 'status': 'SUCCESS', 'technique': 'run_advanced_retopology', 'object': obj.name, 'optimized': True } except Exception as e: logger.error(f"âŒ Advanced retopology failed: {str(e)}") return {'status': 'ERROR', 'error': str(e)} def apply_generative_texture(parameters: Dict) -> Dict[str, Any]: """ Mesh Engine: Apply generative AI-created surface textures Creates complex, AI-generated surface patterns and materials. """ logger.info("ðŸŽ¨ Mesh Engine: Applying generative texture...") texture_type = parameters.get('texture_type', 'procedural_pattern') complexity = parameters.get('complexity', 0.7) color_variation = parameters.get('color_variation', 0.5) try: obj = bpy.context.active_object if not obj: logger.warning("No object for texture application") return {'status': 'NO_OBJECT', 'message': 'No object available for texturing'} # Create new material for generative texture material = bpy.data.materials.new(name="_GenerativeTexture") material.use_nodes = True # Clear default nodes nodes = material.node_tree.nodes nodes.clear() # Create principled BSDF bsdf = nodes.new(type='ShaderNodeBsdfPrincipled') output = nodes.new(type='ShaderNodeOutputMaterial') # Create noise texture for complexity noise = nodes.new(type='ShaderNodeTexNoise') noise.inputs['Scale'].default_value = complexity * 10 noise.inputs['Detail'].default_value = 5.0 # Create color ramp for variation color_ramp = nodes.new(type='ShaderNodeValToRGB') color_ramp.color_ramp.elements[0].color = (0.2, 0.2, 0.8, 1.0) # Blue color_ramp.color_ramp.elements[1].color = (0.8, 0.2, 0.2, 1.0) # Red # Connect nodes material.node_tree.links.new(noise.outputs['Fac'], color_ramp.inputs['Fac']) material.node_tree.links.new(color_ramp.outputs['Color'], bsdf.inputs['Base Color']) material.node_tree.links.new(bsdf.outputs['BSDF'], output.inputs['Surface']) # Apply material to object if obj.data.materials: obj.data.materials[0] = material else: obj.data.materials.append(material) logger.info(f"âœ… Generative texture applied: {texture_type}") return { 'status': 'SUCCESS', 'technique': 'apply_generative_texture', 'object': obj.name, 'material': material.name, 'texture_type': texture_type } except Exception as e: logger.error(f"âŒ Generative texture failed: {str(e)}") return {'status': 'ERROR', 'error': str(e)} # ============================================================================= # DYNAMIC CONSTRUCTION PLAN EXECUTOR - CORE INNOVATION # ============================================================================= def execute_construction_plan(construction_plan: List[Dict], context: Dict) -> bpy.types.Object: """ Enhanced Dynamic Construction Plan Executor with robust error handling. This is the revolutionary "Robotic Arm" that receives a list of operations from the AI and executes them sequentially by calling functions from procedural_knowledge.py. Enhancement: Comprehensive error handling and graceful degradation for unknown operations. Args: construction_plan: List of operations from AI Master Blueprint context: Execution context with settings and parameters Returns: Final assembled object after executing all operations Raises: RuntimeError: If no operations can be executed successfully """ logger.info("=== ENHANCED DYNAMIC CONSTRUCTION PLAN EXECUTION ===") logger.info(f"Executing {len(construction_plan)} operations from AI Master Planner") # : Import procedural knowledge base with error handling try: import sys import os addon_root = os.path.dirname(os.path.abspath(__file__)) backend_path = os.path.join(addon_root, "backend") if backend_path not in sys.path: sys.path.append(backend_path) from procedural_knowledge import execute_operation logger.info(": Procedural knowledge base loaded successfully") except ImportError as e: logger.error(f": Critical error - Cannot load procedural knowledge base: {e}") raise RuntimeError(f"Blender Engine initialization failed: {e}") # Initialize context objects for inter-operation communication context_objects = {"base": None} final_object = None successful_operations = 0 # : Execute each operation with individual error handling for i, operation in enumerate(construction_plan): operation_name = operation.get('operation', 'unknown') parameters = operation.get('parameters', {}) logger.info(f": Operation {i+1}/{len(construction_plan)}: {operation_name}") logger.info(f": Parameters: {parameters}") try: # Execute the operation using procedural knowledge result_object = execute_operation(operation, context_objects) if result_object: final_object = result_object context_objects['base'] = result_object context_objects[f'step_{i+1}'] = result_object successful_operations += 1 logger.info(f"âœ… : Operation {operation_name} completed successfully") else: logger.warning(f"âš ï¸ : Operation {operation_name} returned no object") except Exception as e: logger.error(f"âŒ : Operation {operation_name} failed: {e}") # : Continue with next operation - graceful degradation continue # : Comprehensive validation of execution results if final_object is None: logger.error("âŒ : No operations produced a valid object - construction plan failed") raise RuntimeError(": Construction plan execution failed - no valid objects created") if successful_operations == 0: logger.error("âŒ : Zero operations executed successfully") raise RuntimeError(": Construction plan execution failed - no operations succeeded") logger.info(f"âœ… : Construction plan execution completed successfully") logger.info(f": Final object: {final_object.name}, Operations completed: {successful_operations}/{len(construction_plan)}") return final_object def generate_dynamic_procedural_asset(args, blueprint: Dict) -> bpy.types.Object: """ Main asset generation function - executes the AI's construction_plan dynamically. This function replaces the previous implicit-function based workflow with a pure procedural approach where the AI generates a sequence of operations that are executed by the Blender Engine. Args: args: Command line arguments blueprint: Master Blueprint containing construction_plan from AI Returns: Final assembled procedural asset object """ logger.info("=== DYNAMIC PROCEDURAL ASSET GENERATION ===") # Extract construction plan from blueprint construction_plan = blueprint.get('construction_plan', []) if not construction_plan: logger.error("âŒ No construction_plan found in Master Blueprint") raise ValueError("Master Blueprint must contain a construction_plan with operations") logger.info(f"AI Master Blueprint contains {len(construction_plan)} operations:") for i, op in enumerate(construction_plan): logger.info(f" {i+1}. {op.get('operation', 'unknown')} - {op.get('parameters', {})}") # Execute the construction plan dynamically context = { 'asset_scale_mm': getattr(args, 'asset_scale_mm', 20.0), 'material_specs': blueprint.get('material_specifications', {}), 'reasoning': blueprint.get('reasoning', 'No reasoning provided') } final_object = execute_construction_plan(construction_plan, context) # Scale appropriately for real-world size asset_scale_mm = getattr(args, 'asset_scale_mm', 20.0) scale_factor = asset_scale_mm / 1000.0 # Convert mm to meters final_object.scale = (scale_factor, scale_factor, scale_factor) # Apply scale transformation bpy.context.view_layer.objects.active = final_object bpy.ops.object.transform_apply(scale=True) final_object.name = "_Dynamic_Procedural_Asset" logger.info(" Dynamic procedural asset generation completed successfully") return final_object # ============================================================================= # PROFESSIONAL HELPER FUNCTIONS - STATE-OF-THE-ART IMPLEMENTATION # ============================================================================= def setup_scene() -> bpy.types.Scene: """ Programmatically create a new, clean Blender scene. Ensures no artifacts from previous runs - professional best practice. Returns: Clean Blender scene ready for operations """ logger.info("Setting up clean professional scene") # Clear all existing data bpy.ops.wm.read_factory_settings(use_empty=True) # Delete default objects if they exist bpy.ops.object.select_all(action='SELECT') bpy.ops.object.delete(use_global=False) # Clear all materials and textures for material in bpy.data.materials: bpy.data.materials.remove(material, do_unlink=True) for texture in bpy.data.textures: bpy.data.textures.remove(texture, do_unlink=True) scene = bpy.context.scene scene.name = "_Professional_Scene" logger.info("Clean scene setup completed") return scene def setup_lighting() -> List[bpy.types.Object]: """ Create professional three-point lighting setup. Implements industry-standard lighting as demonstrated in OpenAI script. Returns: List of light objects created """ logger.info("Setting up professional three-point lighting") lights = [] # Key Light - Primary illumination bpy.ops.object.light_add(type='SUN', location=(5, 5, 10)) key_light = bpy.context.active_object key_light.name = "Key_Light" key_light.data.energy = 3.0 key_light.data.color = (1.0, 0.95, 0.9) # Warm white lights.append(key_light) # Fill Light - Shadow softening bpy.ops.object.light_add(type='SUN', location=(-5, 3, 8)) fill_light = bpy.context.active_object fill_light.name = "Fill_Light" fill_light.data.energy = 1.5 fill_light.data.color = (0.9, 0.95, 1.0) # Cool white lights.append(fill_light) # Rim Light - Edge definition bpy.ops.object.light_add(type='SUN', location=(0, -8, 6)) rim_light = bpy.context.active_object rim_light.name = "Rim_Light" rim_light.data.energy = 2.0 rim_light.data.color = (1.0, 1.0, 1.0) # Pure white lights.append(rim_light) # Environment lighting for jewelry reflections world = bpy.context.scene.world world.use_nodes = True env_tex = world.node_tree.nodes.new('ShaderNodeTexEnvironment') bg_shader = world.node_tree.nodes['Background'] world.node_tree.links.new(env_tex.outputs['Color'], bg_shader.inputs['Color']) bg_shader.inputs['Strength'].default_value = 0.3 logger.info(f"Professional lighting setup completed - {len(lights)} lights created") return lights def enable_gpu_rendering(scene: bpy.types.Scene) -> bool: """ Intelligently detect and configure the best available GPU for Cycles rendering. Implements the same robust device detection as the official OpenAI script. Args: scene: Blender scene to configure Returns: True if GPU enabled, False if falling back to CPU """ logger.info("Detecting and configuring optimal rendering device") # Enable Cycles rendering engine scene.render.engine = 'CYCLES' cycles = scene.cycles # Get preferences for device configuration preferences = bpy.context.preferences cycles_prefs = preferences.addons['cycles'].preferences # Try to get compute devices cycles_prefs.refresh_devices() devices = cycles_prefs.devices if not devices: logger.warning("No compute devices found - using CPU rendering") cycles.device = 'CPU' return False # Device priority: OPTIX > CUDA > HIP > METAL > OPENCL device_preferences = ['OPTIX', 'CUDA', 'HIP', 'METAL', 'OPENCL'] best_device = None best_priority = float('inf') for device in devices: if device.type in device_preferences: priority = device_preferences.index(device.type) if priority < best_priority: best_device = device best_priority = priority if best_device: # Enable the best device for device in devices: device.use = (device == best_device) cycles.device = 'GPU' logger.info(f"GPU rendering enabled: {best_device.name} ({best_device.type})") # Optimize for GPU rendering cycles.use_adaptive_sampling = True cycles.adaptive_threshold = 0.1 cycles.samples = 512 # Professional quality samples return True else: logger.warning("No compatible GPU found - using CPU rendering") cycles.device = 'CPU' cycles.samples = 128 # Fewer samples for CPU return False def frame_camera_to_object(camera: bpy.types.Object, target_obj: bpy.types.Object) -> None: """ Mathematically calculate object bounding box and dynamically position camera for perfect composition. This is the most significant upgrade. Args: camera: Camera object to position target_obj: Object to frame in the shot """ logger.info("Calculating dynamic camera framing for perfect composition") # Get world-space bounding box of target object bbox_corners = [target_obj.matrix_world @ Vector(corner) for corner in target_obj.bound_box] # Calculate bounding box center and dimensions min_coords = Vector(( min(corner.x for corner in bbox_corners), min(corner.y for corner in bbox_corners), min(corner.z for corner in bbox_corners) )) max_coords = Vector(( max(corner.x for corner in bbox_corners), max(corner.y for corner in bbox_corners), max(corner.z for corner in bbox_corners) )) bbox_center = (min_coords + max_coords) / 2 bbox_dimensions = max_coords - min_coords max_dimension = max(bbox_dimensions) # Calculate optimal camera distance for framing # Using field of view to ensure object fits in frame with margin camera_data = camera.data fov_radians = camera_data.angle margin_factor = 1.3 # 30% margin around object optimal_distance = (max_dimension * margin_factor) / (2 * math.tan(fov_radians / 2)) # Position camera at optimal viewing angle (45-degree elevation, 30-degree rotation) camera_offset = Vector(( optimal_distance * math.cos(math.radians(30)) * math.cos(math.radians(45)), optimal_distance * math.sin(math.radians(30)) * math.cos(math.radians(45)), optimal_distance * math.sin(math.radians(45)) )) camera.location = bbox_center + camera_offset # Point camera at object center direction = bbox_center - camera.location rot_quat = direction.to_track_quat('-Z', 'Y') camera.rotation_euler = rot_quat.to_euler() # Fine-tune focal length for jewelry photography camera_data.lens = 85 # Portrait lens equivalent - ideal for jewelry logger.info(f"Camera positioned at {camera.location} targeting {bbox_center}") logger.info(f"Object dimensions: {bbox_dimensions}, optimal distance: {optimal_distance:.3f}") def create_blender_mesh_from_construction_plan(construction_plan: List[Dict], object_name: str = "Procedural_Object") -> bpy.types.Object: """ : Create Blender mesh object from construction plan operations. This replaces the previous implicit function mesh creation. Args: construction_plan: List of operations to execute object_name: Name for the created object Returns: Blender object created from construction plan """ logger.info(f"Creating Blender mesh from {len(construction_plan)} construction plan operations") # Execute the construction plan context = {} result_object = execute_construction_plan(construction_plan, context) if result_object: result_object.name = object_name # Center the object bpy.context.view_layer.objects.active = result_object bpy.ops.object.origin_set(type='GEOMETRY_TO_ORIGIN') logger.info(f"Construction plan mesh created successfully: {object_name}") return result_object else: raise RuntimeError("Failed to create object from construction plan") def render_preview(scene: bpy.types.Scene, output_path: str) -> str: """ Configure professional render settings and execute preview render. Args: scene: Blender scene to render output_path: Path for preview image output Returns: Path to rendered preview image """ logger.info("Configuring professional preview render") # Set professional render settings render = scene.render render.resolution_x = 1920 render.resolution_y = 1080 render.resolution_percentage = 100 # Professional output settings render.image_settings.file_format = 'PNG' render.image_settings.color_mode = 'RGBA' render.image_settings.compression = 15 # PNG compression # Professional color management scene.view_settings.view_transform = 'Standard' scene.view_settings.look = 'Medium High Contrast' # Set output path for preview preview_path = output_path.replace('.stl', '_preview.png') render.filepath = preview_path logger.info(f"Rendering professional preview: {preview_path}") # Execute render bpy.ops.render.render(write_still=True) logger.info("Professional preview render completed") return preview_path def export_stl(obj: bpy.types.Object, output_path: str) -> None: """ Clean STL export of the final manufacturable model. Args: obj: Object to export output_path: Path for STL file output """ logger.info(f"Exporting manufacturable STL: {output_path}") # Enable STL addon try: addon_utils.enable("io_mesh_stl") except Exception as e: logger.warning(f"STL addon already enabled: {e}") # Apply all modifiers before export bpy.context.view_layer.objects.active = obj for mod in obj.modifiers[:]: # Copy list to avoid iteration issues try: bpy.ops.object.modifier_apply(modifier=mod.name) logger.debug(f"Applied modifier: {mod.name}") except RuntimeError as e: logger.warning(f"Could not apply modifier {mod.name}: {e}") # Select only the final object bpy.ops.object.select_all(action='DESELECT') obj.select_set(True) # Export with professional settings bpy.ops.export_mesh.stl( filepath=output_path, use_selection=True, global_scale=1000.0, # Convert meters to millimeters use_mesh_modifiers=True, axis_forward='-Z', axis_up='Y' ) logger.info("STL export completed successfully") # ============================================================================= # GEOMETRIC ANALYSIS MODE - COGNITIVE LOOP INTELLIGENCE # ============================================================================= def analyze_geometry(input_path: str, output_path: str) -> None: """ Analysis Mode: Perform geometric analysis of an STL file. Args: input_path: Path to STL file to analyze output_path: Path for JSON analysis output """ logger.info("=== BLENDER ENGINE - GEOMETRIC ANALYSIS MODE ===") logger.info(f"Analyzing STL file: {input_path}") # Setup clean scene scene = setup_scene() # Import the STL file if not os.path.exists(input_path): raise FileNotFoundError(f"STL file not found: {input_path}") # Import STL bpy.ops.import_mesh.stl(filepath=input_path) analyzed_object = bpy.context.active_object if not analyzed_object: raise RuntimeError("Failed to import STL file") # Ensure we're in object mode for analysis bpy.context.view_layer.objects.active = analyzed_object bpy.ops.object.mode_set(mode='OBJECT') # Get mesh data mesh = analyzed_object.data # Calculate bounding box bbox = [analyzed_object.matrix_world @ Vector(corner) for corner in analyzed_object.bound_box] bbox_min = Vector((min(pt.x for pt in bbox), min(pt.y for pt in bbox), min(pt.z for pt in bbox))) bbox_max = Vector((max(pt.x for pt in bbox), max(pt.y for pt in bbox), max(pt.z for pt in bbox))) dimensions = bbox_max - bbox_min # Calculate volume (approximate using bounding box) volume_approx = dimensions.x * dimensions.y * dimensions.z # Calculate surface area (approximate) bpy.context.view_layer.objects.active = analyzed_object bpy.ops.object.mode_set(mode='EDIT') bpy.ops.mesh.select_all(action='SELECT') bpy.ops.object.mode_set(mode='OBJECT') # Get mesh statistics vertex_count = len(mesh.vertices) edge_count = len(mesh.edges) face_count = len(mesh.polygons) # Calculate center of mass center_of_mass = analyzed_object.location + (bbox_min + bbox_max) * 0.5 # Generate analysis report analysis_report = { "analysis_timestamp": str(json.dumps({"timestamp": time.time()})).strip('"'), "geometry_metrics": { "vertex_count": vertex_count, "edge_count": edge_count, "face_count": face_count, "bounding_box": { "min": [bbox_min.x, bbox_min.y, bbox_min.z], "max": [bbox_max.x, bbox_max.y, bbox_max.z], "dimensions": [dimensions.x, dimensions.y, dimensions.z] }, "approximate_volume_cubic_mm": volume_approx * 1000000, # Convert to mmÂ³ "center_of_mass": [center_of_mass.x, center_of_mass.y, center_of_mass.z] }, "manufacturing_assessment": { "complexity_level": "high" if face_count > 1000 else "medium" if face_count > 500 else "low", "printability_score": 0.9 if face_count < 2000 else 0.7, "estimated_material_usage_grams": volume_approx * 19.3 * 1000, # Assuming gold density "structural_integrity": "good" if vertex_count > 100 else "needs_review" }, "design_characteristics": { "dominant_dimension": "width" if dimensions.x > max(dimensions.y, dimensions.z) else "height" if dimensions.y > dimensions.z else "depth", "aspect_ratio": max(dimensions.x, dimensions.y, dimensions.z) / min(dimensions.x, dimensions.y, dimensions.z), "symmetry_assessment": "likely_symmetric" if abs(center_of_mass.x) < 0.001 else "asymmetric" } } # Write analysis to JSON file with open(output_path, 'w') as f: json.dump(analysis_report, f, indent=2) logger.info(f"Geometric analysis completed: {output_path}") logger.info(f"Vertices: {vertex_count}, Faces: {face_count}") logger.info(f"Dimensions: {dimensions.x:.3f}x{dimensions.y:.3f}x{dimensions.z:.3f}") logger.info("=== GEOMETRIC ANALYSIS COMPLETED ===") # ============================================================================= # MAIN EXECUTION FUNCTION - PROFESSIONAL ORCHESTRATION # ============================================================================= def main(): """ Main execution function - Dynamic Construction Plan Executor. The revolutionary transformation: instead of processing implicit functions, this now executes AI-generated construction plans dynamically. The Blender Engine has become a lean, intelligent interpreter that: 1. Receives construction_plan from AI Master Planner 2. Loops through operations and calls procedural_knowledge functions 3. Assembles the final object with zero hardcoded creative logic """ if '--' not in sys.argv: logger.error("No arguments provided. Script must be called with -- separator.") return parser = ArgumentParser(description=" Dynamic Construction Plan Executor") parser.add_argument("--mode", type=str, choices=["execute", "analyze"], default="execute", help="Operation mode: 'execute' for construction plan execution, 'analyze' for geometric analysis") parser.add_argument("--construction_plan", type=str, required=True, help="JSON string containing the AI's construction plan") parser.add_argument("--output", type=str, required=True, help="Path for final .stl export or analysis JSON") parser.add_argument("--asset_scale_mm", type=float, default=20.0, help="Scale of final procedural asset in millimeters") parser.add_argument("--material", type=str, default='GOLD', help="Material type for the asset") argv = sys.argv[sys.argv.index('--') + 1:] args = parser.parse_args(argv) logger.info("=== Advanced Design BLENDER MESH ENGINE ===") logger.info("Revolutionary AI-driven mesh artistry workflow") logger.info(f"Mode: {args.mode.upper()}") logger.info(f"Output: {args.output}") logger.info(f"Asset Scale: {args.asset_scale_mm}mm") if args.mode == "analyze": # Legacy analysis mode for backward compatibility analyze_geometry(args.construction_plan, args.output) # Use construction_plan as input path return # Advanced Design Mesh Engine Execution Mode logger.info("Executing AI Master Planner construction plan") try: # Parse the construction plan from AI blueprint = json.loads(args.construction_plan) logger.info(" Master Blueprint with construction_plan parsed successfully") construction_plan = blueprint.get('construction_plan', []) if not construction_plan: raise ValueError("No construction_plan found in Master Blueprint") logger.info(f"Construction plan contains {len(construction_plan)} operations:") for i, operation in enumerate(construction_plan): logger.info(f" {i+1}. {operation.get('operation', 'unknown')}") # Step 1: Setup professional scene scene = setup_scene() # Step 2: Configure professional lighting lights = setup_lighting() # Step 3: Enable optimal GPU rendering gpu_enabled = enable_gpu_rendering(scene) # Step 4: Execute dynamic construction plan - CORE INNOVATION final_object = generate_dynamic_procedural_asset(args, blueprint) # Step 5: Create and position camera for dynamic framing bpy.ops.object.camera_add(location=(0, 0, 0)) camera = bpy.context.active_object camera.name = "Dynamic_Frame_Camera" scene.camera = camera # Step 6: Apply dynamic camera framing frame_camera_to_object(camera, final_object) # Step 7: Render professional preview preview_path = render_preview(scene, args.output) # Step 8: Export final manufacturable STL export_stl(final_object, args.output) logger.info("=== Advanced Design MESH ENGINE EXECUTION COMPLETED ===") logger.info(f"GPU Rendering: {'Enabled' if gpu_enabled else 'Disabled (CPU fallback)'}") logger.info(f"Final STL: {args.output}") logger.info(f"Preview Image: {preview_path}") logger.info(f"Operations Executed: {len(construction_plan)}") logger.info(f"AI Master Planner reasoning: {blueprint.get('reasoning', 'No reasoning provided')}") logger.info("Revolutionary dynamic construction plan workflow completed") except json.JSONDecodeError as e: logger.error(f"Invalid JSON in construction plan: {e}") sys.exit(1) except Exception as e: logger.exception(f" Dynamic construction plan execution failed: {e}") sys.exit(1) if __name__ == "__main__": main()