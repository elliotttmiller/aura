"""
Aura V5.0 Hyper-Parametric Blender Executor
==========================================

This script is a deterministic procedural engine that executes the AI's Master Blueprint
with zero creative logic. Given the same JSON Master Blueprint, it produces the exact
same 3D model every time.

Part of the V5.0 Autonomous Cognitive Architecture.
"""

import os
import sys
import json
import math
import logging
from argparse import ArgumentParser
import bpy
import bmesh
import addon_utils

# Setup logger
logging.basicConfig(level=logging.DEBUG, format='[%(asctime)s] %(levelname)s %(message)s')
logger = logging.getLogger(__name__)

def load_obj_geometry(obj_path: str) -> bpy.types.Object:
    """
    Load the AI-generated .obj file into Blender.
    
    Args:
        obj_path: Path to the .obj file generated by Shap-E
        
    Returns:
        Blender object containing the loaded geometry
    """
    logger.info(f"Loading AI-generated geometry from: {obj_path}")
    
    # Clear existing objects
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()
    
    # Import the OBJ file
    try:
        bpy.ops.import_scene.obj(filepath=obj_path)
        imported_objects = bpy.context.selected_objects
        
        if not imported_objects:
            raise RuntimeError("No objects imported from OBJ file")
            
        # Get the main imported object
        ai_geometry = imported_objects[0]
        ai_geometry.name = "AI_Base_Geometry"
        
        logger.info(f"Successfully loaded AI geometry: {ai_geometry.name}")
        return ai_geometry
        
    except Exception as e:
        logger.error(f"Failed to import OBJ file: {e}")
        raise

def create_parametric_shank(params: dict, ring_size: float) -> bpy.types.Object:
    """
    Create ring shank based on Master Blueprint parameters.
    
    Args:
        params: shank_parameters from Master Blueprint
        ring_size: US ring size
        
    Returns:
        Blender object containing the shank geometry
    """
    logger.info(f"Creating parametric shank: {params}")
    
    # Calculate ring dimensions
    ring_diameter_mm = 12.45 + (ring_size * 0.8128)
    ring_radius = (ring_diameter_mm / 2) / 1000  # Convert to meters
    
    # Extract parameters
    profile_shape = params.get('profile_shape', 'Round')
    thickness_mm = params.get('thickness_mm', 2.0)
    thickness = thickness_mm / 1000  # Convert to meters
    
    # Create new bmesh
    bm = bmesh.new()
    
    # Create profile based on shape
    if profile_shape == 'D-Shape':
        # Create D-shaped profile
        profile_geom = bmesh.ops.create_circle(bm, cap_ends=False, radius=thickness/2, segments=16)
        # Flatten one side for D-shape
        for v in profile_geom['verts']:
            if v.co.x < 0:
                v.co.x = 0
        bmesh.ops.translate(bm, verts=profile_geom['verts'], vec=(thickness/2, 0, 0))
    else:  # Round
        profile_geom = bmesh.ops.create_circle(bm, cap_ends=False, radius=thickness/2, segments=16)
        bmesh.ops.translate(bm, verts=profile_geom['verts'], vec=(ring_radius + thickness/2, 0, 0))
    
    # Create ring by spinning profile around center
    bmesh.ops.spin(bm, geom=profile_geom['verts'], cent=(0,0,0), axis=(0,1,0), 
                   steps=128, angle=math.radians(360))
    
    # Create mesh object
    shank_mesh = bpy.data.meshes.new("Parametric_Shank")
    bm.to_mesh(shank_mesh)
    bm.free()
    
    shank_obj = bpy.data.objects.new("Parametric_Shank", shank_mesh)
    bpy.context.scene.collection.objects.link(shank_obj)
    
    logger.info("Parametric shank created successfully")
    return shank_obj

def create_parametric_setting(params: dict, stone_carat: float, ring_radius: float) -> bpy.types.Object:
    """
    Create stone setting based on Master Blueprint parameters.
    
    Args:
        params: setting_parameters from Master Blueprint
        stone_carat: Carat weight of stone
        ring_radius: Ring radius in meters
        
    Returns:
        Blender object containing the setting geometry
    """
    logger.info(f"Creating parametric setting: {params}")
    
    # Extract parameters
    prong_count = params.get('prong_count', 4)
    style = params.get('style', 'Classic')
    height_above_shank_mm = params.get('height_above_shank_mm', 3.0)
    height_offset = height_above_shank_mm / 1000  # Convert to meters
    
    # Calculate stone dimensions
    stone_diameter_mm = 6.5 * (stone_carat ** (1./3.))
    stone_radius = (stone_diameter_mm / 2) / 1000  # Convert to meters
    
    # Create setting bmesh
    setting_bm = bmesh.new()
    
    # Create prongs
    for i in range(prong_count):
        angle = i * (2 * math.pi / prong_count)
        
        # Create prong geometry
        prong = bmesh.ops.create_cone(setting_bm, cap_ends=True, 
                                      radius1=0.0005, radius2=0.0002, 
                                      depth=0.004, segments=8)
        
        # Position prong
        x = math.cos(angle) * (stone_radius * 0.9)
        y = math.sin(angle) * (stone_radius * 0.9)
        z = ring_radius + height_offset
        
        # Apply style modification
        if style == 'Sweeping':
            # Create curved prongs
            for v in prong['verts']:
                # Apply slight curve
                curve_factor = v.co.z * 0.1
                v.co.x *= (1 + curve_factor)
                v.co.y *= (1 + curve_factor)
        
        bmesh.ops.translate(setting_bm, verts=prong['verts'], vec=(x, y, z))
    
    # Create mesh object
    setting_mesh = bpy.data.meshes.new("Parametric_Setting")
    setting_bm.to_mesh(setting_mesh)
    setting_bm.free()
    
    setting_obj = bpy.data.objects.new("Parametric_Setting", setting_mesh)
    bpy.context.scene.collection.objects.link(setting_obj)
    
    logger.info("Parametric setting created successfully")
    return setting_obj

def apply_artistic_modifiers(obj: bpy.types.Object, params: dict):
    """
    Apply artistic modifications based on Master Blueprint parameters.
    
    Args:
        obj: Blender object to modify
        params: artistic_modifier_parameters from Master Blueprint
    """
    logger.info(f"Applying artistic modifiers: {params}")
    
    twist_angle_degrees = params.get('twist_angle_degrees', 0)
    organic_displacement_strength = params.get('organic_displacement_strength', 0.0)
    
    # Apply twist if specified
    if twist_angle_degrees > 0:
        logger.debug(f"Applying twist modifier: {twist_angle_degrees} degrees")
        twist_mod = obj.modifiers.new(name="Blueprint_Twist", type='SIMPLE_DEFORM')
        twist_mod.deform_method = 'TWIST'
        twist_mod.angle = math.radians(twist_angle_degrees)
    
    # Apply organic displacement if specified  
    if organic_displacement_strength > 0:
        logger.debug(f"Applying organic displacement: {organic_displacement_strength}")
        
        # Create noise texture
        noise_tex = bpy.data.textures.new(name="Blueprint_Noise", type='VORONOI')
        noise_tex.noise_scale = 0.5
        
        # Apply displacement modifier
        disp_mod = obj.modifiers.new(name="Blueprint_Organic", type='DISPLACE')
        disp_mod.texture = noise_tex
        disp_mod.strength = organic_displacement_strength

def execute_master_blueprint(blueprint: dict, ai_obj_path: str, user_specs: dict) -> bpy.types.Object:
    """
    Execute the complete Master Blueprint from the AI System Architect.
    
    Args:
        blueprint: Complete JSON Master Blueprint from LLM
        ai_obj_path: Path to AI-generated base geometry
        user_specs: User specifications (ring_size, etc.)
        
    Returns:
        Final assembled Blender object
    """
    logger.info("Executing Master Blueprint...")
    logger.debug(f"Blueprint: {json.dumps(blueprint, indent=2)}")
    
    # Step 1: Load AI-generated base geometry
    ai_geometry = load_obj_geometry(ai_obj_path)
    
    # Step 2: Create parametric shank
    shank_obj = create_parametric_shank(
        blueprint['shank_parameters'], 
        user_specs['ring_size']
    )
    
    # Step 3: Create parametric setting
    ring_diameter_mm = 12.45 + (user_specs['ring_size'] * 0.8128)
    ring_radius = (ring_diameter_mm / 2) / 1000
    
    setting_obj = create_parametric_setting(
        blueprint['setting_parameters'],
        user_specs['stone_carat'],
        ring_radius
    )
    
    # Step 4: Apply artistic modifiers to main geometry
    apply_artistic_modifiers(ai_geometry, blueprint['artistic_modifier_parameters'])
    
    # Step 5: Combine all components
    bpy.ops.object.select_all(action='DESELECT')
    ai_geometry.select_set(True)
    shank_obj.select_set(True) 
    setting_obj.select_set(True)
    
    bpy.context.view_layer.objects.active = ai_geometry
    bpy.ops.object.join()
    
    final_object = bpy.context.active_object
    final_object.name = "Aura_V5_Master_Creation"
    
    logger.info("Master Blueprint execution completed successfully")
    return final_object

def main():
    """Main execution function for the Hyper-Parametric Blender Executor."""
    if '--' not in sys.argv:
        logger.error("No arguments provided. Script must be called with -- separator.")
        return
    
    parser = ArgumentParser(description="Aura V5.0 Hyper-Parametric Blender Executor")
    parser.add_argument("--input", type=str, required=True, 
                       help="Path to AI-generated .obj file")
    parser.add_argument("--output", type=str, required=True,
                       help="Path for final .stl export")
    parser.add_argument("--params", type=str, required=True,
                       help="JSON Master Blueprint parameters")
    parser.add_argument("--ring_size", type=float, default=7.0)
    parser.add_argument("--stone_carat", type=float, default=1.0)
    parser.add_argument("--stone_shape", type=str, default='ROUND')
    parser.add_argument("--metal", type=str, default='GOLD')
    
    argv = sys.argv[sys.argv.index('--') + 1:]
    args = parser.parse_args(argv)
    
    logger.info("=== AURA V5.0 HYPER-PARAMETRIC BLENDER EXECUTOR ===")
    logger.info(f"Input AI geometry: {args.input}")
    logger.info(f"Output file: {args.output}")
    logger.info(f"User specs: ring_size={args.ring_size}, stone_carat={args.stone_carat}")
    
    try:
        # Parse the Master Blueprint
        blueprint = json.loads(args.params)
        logger.info("Master Blueprint parsed successfully")
        
        # Enable STL addon
        try:
            addon_utils.enable("io_mesh_stl")
        except Exception as e:
            logger.warning(f"Could not enable STL add-on: {e}")
        
        # Prepare user specifications
        user_specs = {
            'ring_size': args.ring_size,
            'stone_carat': args.stone_carat,
            'stone_shape': args.stone_shape,
            'metal': args.metal
        }
        
        # Execute the Master Blueprint
        final_object = execute_master_blueprint(blueprint, args.input, user_specs)
        
        # Apply all modifiers
        bpy.context.view_layer.objects.active = final_object
        for mod in final_object.modifiers:
            try:
                bpy.ops.object.modifier_apply(modifier=mod.name)
                logger.debug(f"Applied modifier: {mod.name}")
            except RuntimeError as e:
                logger.warning(f"Could not apply modifier {mod.name}: {e}")
        
        # Export final STL
        logger.info(f"Exporting final model to: {args.output}")
        bpy.ops.object.select_all(action='DESELECT')
        final_object.select_set(True)
        
        bpy.ops.export_mesh.stl(
            filepath=args.output, 
            use_selection=True, 
            global_scale=1000.0  # Convert meters to mm
        )
        
        logger.info("=== MASTER BLUEPRINT EXECUTION COMPLETED SUCCESSFULLY ===")
        
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in Master Blueprint: {e}")
        sys.exit(1)
    except Exception as e:
        logger.exception(f"Master Blueprint execution failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()